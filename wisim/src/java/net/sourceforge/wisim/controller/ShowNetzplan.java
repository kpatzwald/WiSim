package net.sourceforge.wisim.controller;

import java.awt.Graphics;
import java.util.Iterator;
import java.util.Vector;

import javax.swing.JPanel;
import javax.swing.JScrollPane;

/*
 * JustTesting.java
 *
 * Created on 25. Mai 2003, 19:21
 */

/**
 *
 * @author  Ben du bist einfach gut :-)
 */
public class ShowNetzplan extends javax.swing.JFrame {

	private static Vector npElemente;
	private JPanel jPanel1;
	private JScrollPane jScrollPane1;
	private static int maxWidth;
	private static int[][] position;

	/** Creates new form JustTesting */
	public ShowNetzplan() {

		/** Matrix für die Anzeige */
		position = new int[20][20];
		for (int a = 0; a < 20; a++)
			for (int b = 0; b < 20; b++)
				position[a][b] = 0;

		npElemente = new Vector();

		/*npElemente.add(new NetzplanElement(1, 20, new int[] { 2, 6, 8 }, "Entwurf, Planung"));
		npElemente.add(new NetzplanElement(2, 3, new int[] { 3 }, "Erdaushub Fundamente"));
		npElemente.add(new NetzplanElement(3, 2, new int[] { 4 }, "Ausgießen Fundamente"));
		npElemente.add(new NetzplanElement(4, 5, new int[] { 5 }, "Verschalung Betonsockel"));
		npElemente.add(new NetzplanElement(5, 3, new int[] { 9 }, "Betonierung Betonsockel"));
		npElemente.add(new NetzplanElement(6, 10, new int[] { 7 }, "Bestellung Betonteile"));
		npElemente.add(new NetzplanElement(7, 2, new int[] { 9 }, "Aushub Versorgungsleitung"));
		npElemente.add(new NetzplanElement(8, 5, new int[] { 9 }, "Leitungsverlegung"));
		npElemente.add(new NetzplanElement(9, 7, new int[] { 10 }, "Montage Lagerhalle"));
		npElemente.add(new NetzplanElement(10, 4, new int[] { 0 }, "Installationsarbeiten"));*/

		npElemente.add(new NetzplanElement(1, 3, new int[] { 2, 3, 4, 5 }, "Erdaushub Fundamente und so wei"));
		npElemente.add(new NetzplanElement(2, 2, new int[] { 6 }, "Ausgießen Fundamente"));
		npElemente.add(new NetzplanElement(3, 5, new int[] { 6 }, "Verschalung Betonsockel"));
		npElemente.add(new NetzplanElement(4, 3, new int[] { 6 }, "Betonierung Betonsockel"));
		npElemente.add(new NetzplanElement(5, 10, new int[] { 6 }, "Bestellung Betonteile"));
		npElemente.add(new NetzplanElement(6, 2, new int[] { 0 }, "Aushub Versorgungsleitung"));

		NetzplanCalculator npCalc = new NetzplanCalculator(npElemente);
		npElemente = npCalc.getNpElemente();

		maxWidth = npCalc.getMaxWidthOfNetzplan();
		calculatePositions();

		initComponents();
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	private void initComponents() {
		jScrollPane1 = new javax.swing.JScrollPane();
		jPanel1 = new javax.swing.JPanel() {

			/** Netzplan wird gezeichnet */
			public void paint(Graphics g) {
				Vector paintedElements = new Vector();
				NetzplanElementGrafikGenerator npGen[] = new NetzplanElementGrafikGenerator[npElemente.size()];
				int a = 0;
				while (a < npGen.length) {
					npGen[a] = new NetzplanElementGrafikGenerator();
					a++;
				}

				int i = 0;
				for (int b = 0; b < 20; b++) {
					for (int c = 0; c < 20; c++) {
						if (position[b][c] != 0) {
							NetzplanElement np = (NetzplanElement) npElemente.get(position[b][c] - 1);

							if (!paintedElements.contains(new Integer(np.getNummer()))) {
								g.drawImage(npGen[i].generateNetzplanelement(np), 30 + b * 350, 30 + c * 160, null);

								int nachfolger[] = np.getNachfolger();
								if (nachfolger.length > 1) {
									g.drawLine(170 + b * 350, 190 + c * 160, 520 + (nachfolger.length - 2) * 350, 190 + c * 160);

								}

								int vorgaenger[] = np.getVorgaenger();
								if (vorgaenger.length > 1) {
									g.drawLine(
										170 + b * 350,
										190 + (c - 1) * 160,
										520 + (vorgaenger.length - 2) * 350,
										190 + (c - 1) * 160);
								}

								i++;
							} else {
								g.drawLine(170 + b * 350, 10 + c * 160, 170 + b * 350, 190 + c * 160);
							}

							paintedElements.add(new Integer(np.getNummer()));
						}
					}
				}
			}
		};

		getContentPane().setLayout(null);

		addWindowListener(new java.awt.event.WindowAdapter() {
			public void windowClosing(java.awt.event.WindowEvent evt) {
				exitForm(evt);
			}
		});

		jPanel1.setPreferredSize(new java.awt.Dimension(2000, 2000));
		jScrollPane1.setViewportView(jPanel1);

		getContentPane().add(jScrollPane1);
		jScrollPane1.setBounds(0, 0, 1093, 900);
		jScrollPane1.setBackground(java.awt.Color.WHITE);

		java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
		setBounds((screenSize.width - 1100) / 2, (screenSize.height - 900) / 2, 1100, 900);
	}

	/** Exit the Application */
	private void exitForm(java.awt.event.WindowEvent evt) {
		System.exit(0);
	}

	/**
	 * @param args the command line arguments
	 */
	public static void main(String args[]) {
		new ShowNetzplan().show();
	}

	public void calculatePositions() {

		Vector tupel[] = new Vector[100];
		Vector temp = new Vector();
		Vector nachfolgerBasket = new Vector();
		Vector completed = new Vector();
		Vector completedAll = new Vector();

		/** START-Element wird in Vector Tupel abgelegt */
		tupel[0] = new Vector();
		tupel[0].add(new Integer(((NetzplanElement) npElemente.get(0)).getNummer()));
		completedAll.add(new Integer(((NetzplanElement) npElemente.get(0)).getNummer()));

		/** Nachfolger des START-Elementes werden geholt */
		int nachfolger[] = ((NetzplanElement) npElemente.get(0)).getNachfolger();

		/** Alle Nachfolger des START-Elementes kommen in einen Vector */
		int y = 0;
		while (y < nachfolger.length) {
			nachfolgerBasket.add(new Integer(nachfolger[y]));
			y++;
		}

		int i = 1;
		boolean lastElement = false;
		while (!lastElement) {

			int a = 0;
			tupel[i] = new Vector();
			temp = new Vector();

			/** Alle Vorgänge aus dem nachfolgerBasket werden in den aktuellen Tupel geschrieben */
			while (a < nachfolgerBasket.size()) {

				/** Alle Vorgänger des Nachfolgers holen */
				int[] vorgaenger = ((NetzplanElement) npElemente.get(((Integer) nachfolgerBasket.get(a)).intValue() - 1)).getVorgaenger();
				boolean complete = true;
				/** Prüfe ob alle Vorgänger des aktuellen Vorgangs schon abgearbeitet wurden */
				if (vorgaenger.length > 1) {

					int h = 0;

					while (h < vorgaenger.length) {
						NetzplanElement checkCompleted = (NetzplanElement) npElemente.get(vorgaenger[h] - 1);
						h++;

						if (!completedAll.contains(new Integer(checkCompleted.getNummer()))) {
							complete = false;
							break;
						}

						/** Es wird getestet ob alle Vorgänger min. 1 Zeile über ihrem Nachfolger sind */

					}
				}

				/** Vorgänger des aktuellen Vorgangs sind schon abgearbeitet worden */
				if (complete && !completed.contains((Integer) nachfolgerBasket.get(a))) {
					temp.add(npElemente.get(((Integer) nachfolgerBasket.get(a)).intValue() - 1));
					tupel[i].add((Integer) nachfolgerBasket.get(a));
					completed.add(nachfolgerBasket.get(a));

					/** Vorgänger wurde noch nicht abgearbeitet */
				} else if (!complete) {
					tupel[i].add(tupel[i - 1].get(a));
				}
				a++;
			}
			completedAll.addAll(completed);
			nachfolgerBasket = new Vector();

			int b = 0;

			/** 
			 * Für jedes Element im aktuellen Tupel werden die 
			 * Nachfolger in den nachfolgerBasket geschrieben 
			 */
			//while (b < temp.size()) {
			while (b < tupel[i].size()) {
				//nachfolger = ((NetzplanElement) temp.get(b)).getNachfolger();
				nachfolger = ((NetzplanElement) npElemente.get(((Integer) tupel[i].get(b)).intValue() - 1)).getNachfolger();
				int c = 0;
				while (c < nachfolger.length) {
					if (nachfolger[c] != 0) {
						nachfolgerBasket.add(new Integer(nachfolger[c]));
					} else {
						lastElement = true;
					}
					c++;
				}
				b++;
			}

			/** Es geht weiter zum nächsten Tupel */
			i++;
		}

		int blub = 0;
		while (blub < i) {

			String string = "";
			Vector test = (Vector) tupel[blub];
			Iterator testIt = test.iterator();
			while (testIt.hasNext()) {
				int tempInt = ((Integer) testIt.next()).intValue();
				if (tempInt != 0) {
					NetzplanElement npEle = (NetzplanElement) npElemente.get(tempInt - 1);
					string = string + " " + (npEle.getNummer());
				} else {
					string = string + " 0";
				}
			}
			System.out.println("Tupel[" + blub + "]: " + string);
			blub++;
		}

		Iterator completeIt = completed.iterator();
		String completedList = "";
		while (completeIt.hasNext())
			completedList = completedList + " " + String.valueOf(((Integer) completeIt.next()).intValue());
		System.out.println("CompletedList: " + completedList);

		/** Positionen werden verteilt */
		int j = 0;
		while (tupel[j] != null) {
			Vector actTupel = tupel[j];
			Iterator actTupelIt = actTupel.iterator();
			int k = 0;
			while (actTupelIt.hasNext()) {
				int actInt = ((Integer) actTupelIt.next()).intValue();

				if (actInt > 0) {
					NetzplanElement actNpElem = (NetzplanElement) npElemente.get(actInt - 1);
					position[k][j] = actNpElem.getNummer();
				}
				k++;
			}
			j++;
		}
	}
}