/*
 * JPanelArbeitsplatzlager.java
 *
 * Created on 21. März 2003, 21:04
 */

package net.sourceforge.wisim.controller;

import net.sourceforge.wisim.dao.*;
import net.sourceforge.wisim.model.*;
import java.util.*;
import javax.swing.table.*;
import javax.swing.*;

/**
 * Gibt eine Tabellenübersicht aller Arbeitsplätze mit den Beständen der
 * jeweiligen Einzelteile aus. Es lassen sich die Anzahl der Arbeiter
 * pro Arbeitsplatz einstellen.
 * @author  benjamin.pasero
 */
public class JPanelArbeitsplatzlager extends javax.swing.JPanel {
    
    private WiSimDAO dao;
    private Vector arbeitsplaetze;
    private Collection arbeitsplatzLager;
    private int apAnzahl;
    private int apElemAnzahl;
    private JLabel label;
    private JProgressBar jprg;
    private boolean isBuilt;
    private boolean isActive;
    private Vector tempEingangslagerBestand;
    private Vector tempAusgangslagerBestand;
    
    //Logger
    private WiSimLogger wiSimLogger;
    
    /** Creates new form JPanelArbeitsplatzlager
     * @param wiSimMainController
     */
    public JPanelArbeitsplatzlager(WiSimMainController wiSimMainController) {
        wiSimLogger = wiSimMainController.getWiSimLogger();
        initDAO(wiSimMainController);
        arbeitsplaetze = new Vector();
        arbeitsplatzLager = new Vector();
        apAnzahl = 0;
        apElemAnzahl = 0;
        label = new JLabel();
        isBuilt = false;
        isActive = false;
        tempEingangslagerBestand = new Vector();
        tempAusgangslagerBestand = new Vector();
        initComponents();
    }
    
    private void initDAO(WiSimMainController wiSimMainController) {
        dao = wiSimMainController.getDAO();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        jLabelArbeitsplatzlager = new javax.swing.JLabel();
        jPanelArbeitsplatzlager = new javax.swing.JPanel();
        jScrollPaneGesamtliste = new javax.swing.JScrollPane();
        jTableGesamtliste = new javax.swing.JTable();
        jPanelArbeitsplaetze = new javax.swing.JPanel();
        jScrollPaneArbeitsplaetze = new javax.swing.JScrollPane();
        jTableArbeitsplaetze = new JTable()
        {
            public TableCellRenderer getCellRenderer(int row, int column) {
                TableColumn tableColumn = getColumnModel().getColumn(column);
                TableCellRenderer renderer = tableColumn.getCellRenderer();
                if (renderer == null) {
                    Class c = getColumnClass(column);
                    if( c.equals(Object.class) )
                    {
                        Object o = getValueAt(row,column);
                        if( o != null )
                        c = getValueAt(row,column).getClass();
                    }
                    renderer = getDefaultRenderer(c);
                }
                return renderer;
            }

            public TableCellEditor getCellEditor(int row, int column) {
                TableColumn tableColumn = getColumnModel().getColumn(column);
                TableCellEditor editor = tableColumn.getCellEditor();
                if (editor == null) {
                    Class c = getColumnClass(column);
                    if( c.equals(Object.class) )
                    {
                        Object o = getValueAt(row,column);
                        if( o != null )
                        c = getValueAt(row,column).getClass();
                    }
                    editor = getDefaultEditor(c);
                }
                return editor;
            }

        };
        jTableArbeitsplaetze.setSelectionMode(0);
        jPanelArbeiter = new javax.swing.JPanel();
        jButtonOk = new javax.swing.JButton();
        jSpinnerArbeiter = new javax.swing.JSpinner();
        jLabelArbeitsplatz = new javax.swing.JLabel();
        jTextFieldArbeitsplatz = new javax.swing.JTextField();
        jLabelArbeiter = new javax.swing.JLabel();

        setLayout(null);

        addAncestorListener(new javax.swing.event.AncestorListener() {
            public void ancestorMoved(javax.swing.event.AncestorEvent evt) {
            }
            public void ancestorAdded(javax.swing.event.AncestorEvent evt) {
                formAncestorAdded(evt);
            }
            public void ancestorRemoved(javax.swing.event.AncestorEvent evt) {
                formAncestorRemoved(evt);
            }
        });

        jLabelArbeitsplatzlager.setFont(new java.awt.Font("Dialog", 1, 24));
        jLabelArbeitsplatzlager.setText("Arbeitsplatzlager");
        add(jLabelArbeitsplatzlager);
        jLabelArbeitsplatzlager.setBounds(310, 6, 220, 32);

        jPanelArbeitsplatzlager.setLayout(null);

        jPanelArbeitsplatzlager.setBorder(new javax.swing.border.TitledBorder("Arbeitsplatzlager"));
        jTableGesamtliste.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Artikelname", "aktueller Bestand", "Max. Bestand", "Belegung"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jTableGesamtliste.addAncestorListener(new javax.swing.event.AncestorListener() {
            public void ancestorMoved(javax.swing.event.AncestorEvent evt) {
            }
            public void ancestorAdded(javax.swing.event.AncestorEvent evt) {
                jTableGesamtlisteAncestorAdded(evt);
            }
            public void ancestorRemoved(javax.swing.event.AncestorEvent evt) {
            }
        });

        jScrollPaneGesamtliste.setViewportView(jTableGesamtliste);

        jPanelArbeitsplatzlager.add(jScrollPaneGesamtliste);
        jScrollPaneGesamtliste.setBounds(10, 20, 550, 84);

        add(jPanelArbeitsplatzlager);
        jPanelArbeitsplatzlager.setBounds(10, 430, 570, 110);

        jPanelArbeitsplaetze.setLayout(null);

        jPanelArbeitsplaetze.setBorder(new javax.swing.border.TitledBorder("Arbeitspl\u00e4tze"));
        jScrollPaneArbeitsplaetze.addAncestorListener(new javax.swing.event.AncestorListener() {
            public void ancestorMoved(javax.swing.event.AncestorEvent evt) {
            }
            public void ancestorAdded(javax.swing.event.AncestorEvent evt) {
                jScrollPaneArbeitsplaetzeAncestorAdded(evt);
            }
            public void ancestorRemoved(javax.swing.event.AncestorEvent evt) {
            }
        });

        jTableArbeitsplaetze.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Nr. ", "Beschreibung", "Vorgänger", "Nachfolger", "Zeit", "Eingangslager", "Ausgangslager"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jTableArbeitsplaetze.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTableArbeitsplaetzeMouseClicked(evt);
            }
        });

        jScrollPaneArbeitsplaetze.setViewportView(jTableArbeitsplaetze);

        jPanelArbeitsplaetze.add(jScrollPaneArbeitsplaetze);
        jScrollPaneArbeitsplaetze.setBounds(10, 20, 750, 372);

        add(jPanelArbeitsplaetze);
        jPanelArbeitsplaetze.setBounds(10, 30, 770, 400);

        jPanelArbeiter.setLayout(null);

        jPanelArbeiter.setBorder(new javax.swing.border.TitledBorder("Arbeiter"));
        jPanelArbeiter.addAncestorListener(new javax.swing.event.AncestorListener() {
            public void ancestorMoved(javax.swing.event.AncestorEvent evt) {
            }
            public void ancestorAdded(javax.swing.event.AncestorEvent evt) {
                jPanelArbeiterAncestorAdded(evt);
            }
            public void ancestorRemoved(javax.swing.event.AncestorEvent evt) {
            }
        });

        jButtonOk.setText("OK");
        jButtonOk.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonOkActionPerformed(evt);
            }
        });

        jPanelArbeiter.add(jButtonOk);
        jButtonOk.setBounds(60, 80, 70, 20);

        jPanelArbeiter.add(jSpinnerArbeiter);
        jSpinnerArbeiter.setBounds(110, 50, 40, 24);

        jLabelArbeitsplatz.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabelArbeitsplatz.setText("Arbeitsplatz");
        jPanelArbeiter.add(jLabelArbeitsplatz);
        jLabelArbeitsplatz.setBounds(20, 20, 80, 16);

        jTextFieldArbeitsplatz.setEditable(false);
        jPanelArbeiter.add(jTextFieldArbeitsplatz);
        jTextFieldArbeitsplatz.setBounds(110, 20, 40, 20);

        jLabelArbeiter.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        jLabelArbeiter.setText("Arbeiter");
        jPanelArbeiter.add(jLabelArbeiter);
        jLabelArbeiter.setBounds(40, 50, 60, 16);

        add(jPanelArbeiter);
        jPanelArbeiter.setBounds(590, 430, 190, 110);

    }//GEN-END:initComponents
    
    private void formAncestorRemoved(javax.swing.event.AncestorEvent evt) {//GEN-FIRST:event_formAncestorRemoved
        setIsActive(false);
    }//GEN-LAST:event_formAncestorRemoved
    
    private void formAncestorAdded(javax.swing.event.AncestorEvent evt) {//GEN-FIRST:event_formAncestorAdded
        setIsActive(true);
    }//GEN-LAST:event_formAncestorAdded
    
    private void jPanelArbeiterAncestorAdded(javax.swing.event.AncestorEvent evt) {//GEN-FIRST:event_jPanelArbeiterAncestorAdded
        //Reset des Arbeiter-Panes
        jTextFieldArbeitsplatz.setText("");
        jSpinnerArbeiter.setModel(new SpinnerNumberModel(0, 0, 0, 0));
    }//GEN-LAST:event_jPanelArbeiterAncestorAdded
    
    private void jButtonOkActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonOkActionPerformed
        if (!jTextFieldArbeitsplatz.getText().equals("")) {
            setArbeiterZahl(Integer.parseInt(jTextFieldArbeitsplatz.getText()), (Integer)jSpinnerArbeiter.getValue());
        }
        jTextFieldArbeitsplatz.grabFocus();
    }//GEN-LAST:event_jButtonOkActionPerformed
    
    private void jTableGesamtlisteAncestorAdded(javax.swing.event.AncestorEvent evt) {//GEN-FIRST:event_jTableGesamtlisteAncestorAdded
        resetGesamtListe();
    }//GEN-LAST:event_jTableGesamtlisteAncestorAdded
    
    private void jTableArbeitsplaetzeMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTableArbeitsplaetzeMouseClicked
        getArbeitsplatzLagerElemente();
    }//GEN-LAST:event_jTableArbeitsplaetzeMouseClicked
    
    private void jScrollPaneArbeitsplaetzeAncestorAdded(javax.swing.event.AncestorEvent evt) {//GEN-FIRST:event_jScrollPaneArbeitsplaetzeAncestorAdded
        getArbeitsplatzlager();
    }//GEN-LAST:event_jScrollPaneArbeitsplaetzeAncestorAdded
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonOk;
    private javax.swing.JLabel jLabelArbeiter;
    private javax.swing.JLabel jLabelArbeitsplatz;
    private javax.swing.JLabel jLabelArbeitsplatzlager;
    private javax.swing.JPanel jPanelArbeiter;
    private javax.swing.JPanel jPanelArbeitsplaetze;
    private javax.swing.JPanel jPanelArbeitsplatzlager;
    private javax.swing.JScrollPane jScrollPaneArbeitsplaetze;
    private javax.swing.JScrollPane jScrollPaneGesamtliste;
    private javax.swing.JSpinner jSpinnerArbeiter;
    private javax.swing.JTable jTableArbeitsplaetze;
    private javax.swing.JTable jTableGesamtliste;
    private javax.swing.JTextField jTextFieldArbeitsplatz;
    // End of variables declaration//GEN-END:variables
    
    /** Holt alle Eingangs und Ausgangslager aus der DB. */
    public void getArbeitsplatzlager() {
        try {
            arbeitsplaetze = dao.getArbeitsplaetze();
        } catch (WiSimDAOException e) {
            wiSimLogger.log("getArbeitsplatzLager()", e);
        }
        apAnzahl = arbeitsplaetze.size();
        
        setArbeitsplatzTabelle();
        int i = 0;
        Iterator ap_it = arbeitsplaetze.iterator();
        while (ap_it.hasNext()) {
            Arbeitsplatz ap = (Arbeitsplatz) ap_it.next();
            
            jTableArbeitsplaetze.setValueAt(String.valueOf(ap.getNr()), i, 0);
            jTableArbeitsplaetze.setValueAt(ap.getBeschreibung(), i, 1);
            
            String vorgaenger = "";
            int[] vorgaengerNr = ap.getVorgaenger();
            if (vorgaengerNr.length > 0) {
                vorgaenger = String.valueOf(vorgaengerNr[0]);
                int x = 1;
                while (x < vorgaengerNr.length) {
                    vorgaenger = vorgaenger + ", " + vorgaengerNr[x];
                    x++;
                }
            }
            
            String nachfolger = "";
            int[] nachfolgerNr = ap.getNachfolger();
            if (nachfolgerNr.length > 0) {
                nachfolger = String.valueOf(nachfolgerNr[0]);
                int x = 1;
                while (x < nachfolgerNr.length) {
                    nachfolger = nachfolger + ", " + nachfolgerNr[x];
                    x++;
                }
            }
            
            if (vorgaenger.equals("0"))
                jTableArbeitsplaetze.setValueAt("-", i, 2);
            else
                jTableArbeitsplaetze.setValueAt(vorgaenger, i, 2);
            
            if (nachfolger.equals("0"))
                jTableArbeitsplaetze.setValueAt("-", i, 3);
            else
                jTableArbeitsplaetze.setValueAt(nachfolger, i, 3);
            
            jTableArbeitsplaetze.setValueAt(String.valueOf(ap.getDauer()), i, 4);
            
            ArbeitsplatzLager apLager = new ArbeitsplatzLager();
            try {
                apLager = dao.getArbeitsplatzLager(ap.getNr(), 26, "Eingang");
            } catch (WiSimDAOException e) {
                wiSimLogger.log("getArbeitsplatzLager()", e);
            }
            
            tempEingangslagerBestand.add(String.valueOf(apLager.getBestand()));
            
            jprg = new JProgressBar(0, 10);
            jprg.setValue(apLager.getBestand());
            jprg.setToolTipText("Bestand: " + apLager.getBestand());
            if (vorgaenger.equals("0"))
                jprg.setEnabled(false);
            jTableArbeitsplaetze.setValueAt(jprg, i, 5);
            
            try {
                apLager = dao.getArbeitsplatzLager(ap.getNr(), 26, "Ausgang");
            } catch (WiSimDAOException e) {
                wiSimLogger.log("getArbeitsplatzLager()", e);
            }
            
            tempAusgangslagerBestand.add(String.valueOf(apLager.getBestand()));
            
            jprg = new JProgressBar(0, 10);
            jprg.setValue(apLager.getBestand());
            jprg.setToolTipText("Bestand: " + apLager.getBestand());
            if (nachfolger.equals("0"))
                jprg.setEnabled(false);
            jTableArbeitsplaetze.setValueAt(jprg, i, 6);
            
            i++;
        }
    }
    
    /** Zeigt die Elemente eines Arbeitsplatzlagers an. */
    public void getArbeitsplatzLagerElemente() {
        Arbeitsplatz ap = (Arbeitsplatz) arbeitsplaetze.get(jTableArbeitsplaetze.getSelectedRow());
        
        //Arbeiter-Pane
        jTextFieldArbeitsplatz.setText(String.valueOf(ap.getNr()));
        jSpinnerArbeiter.setModel(new SpinnerNumberModel(ap.getAnzahlArbeiter(), 0, 10, 1));
        
        try {
            arbeitsplatzLager = dao.getArbeitsplatzLager(ap.getNr(), "Einzelteil");
        } catch (WiSimDAOException e) {
            wiSimLogger.log("getArbeitsplatzLagerElemente()", e);
        }
        apElemAnzahl = arbeitsplatzLager.size();
        
        if (apElemAnzahl > 0) {
            buildArbeitsplatzLagerElementeTabelle();
        } else {
            resetGesamtListe();
        }
    }
    
    /** Baut die Arbeitsplatz-Tabelle */
    public void buildArbeitsplatzLagerElementeTabelle() {
        setArbeitsplatzLagerElementeTabelle();
        int i = 0;
        Iterator arbeitsplatzLager_it = arbeitsplatzLager.iterator();
        while (arbeitsplatzLager_it.hasNext()) {
            ArbeitsplatzLager apLager = (ArbeitsplatzLager) arbeitsplatzLager_it.next();
            
            Einzelteil et = new Einzelteil();
            try {
                et = dao.getEinzelteil(apLager.getEinzelteilNr());
            } catch (WiSimDAOException e) {
                wiSimLogger.log("buildArbeitsplatzLagerElementeTabelle()", e);
            }
            
            jTableGesamtliste.setValueAt(et.getName(), i, 0);
            jTableGesamtliste.setValueAt(String.valueOf(apLager.getBestand()), i, 1);
            jTableGesamtliste.setValueAt(String.valueOf(apLager.getMaxBestand()), i, 2);
            
            IconGenerater iconGen = new IconGenerater();
            
            double actBestand = apLager.getBestand();
            double actMaxBestand = apLager.getMaxBestand();
            
            double rects = (double)(actBestand/actMaxBestand)*5;
            int filledrectsCount = (int) Math.round(rects);
            
            if (apLager.getBestand() < (apLager.getMaxBestand()/4)) {
                jTableGesamtliste.setValueAt(iconGen.generateIcon(2, filledrectsCount), i, 3);
            } else if ((apLager.getBestand() < (apLager.getMaxBestand()/2))) {
                jTableGesamtliste.setValueAt(iconGen.generateIcon(1, filledrectsCount), i, 3);
            } else {
                jTableGesamtliste.setValueAt(iconGen.generateIcon(0, filledrectsCount), i, 3);
            }
            i++;
        }
    }
    
    /** Erstellt die ArbeitsplatzTabelle. */
    public void setArbeitsplatzTabelle() {
        //DefaultTableModel mit Variablen Zeilen, 4 TableHeads und nicht editierbaren Zellen
        Object[][] tableInit = new Object[apAnzahl][7];
        DefaultTableModel defTable = new DefaultTableModel(
        tableInit,
        new String [] {
            "Nr. ", "Beschreibung", "Vorgänger", "Nachfolger", "Zeit", "Eingangslager", "Ausgangslager"
        }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false
            };
            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
            public Class getColumnClass(int c) {
                return getValueAt(0, c).getClass();
            }
        };
        jTableArbeitsplaetze.setModel(defTable);
        jTableArbeitsplaetze.setFocusable(false);
        jTableArbeitsplaetze.getTableHeader().setReorderingAllowed(false);
        
        javax.swing.table.TableColumn column = null;
        
        //Spaltenbreiten der Tabelle werden gesetzt
        for (int i = 0; i < 7; i++) {
            column = jTableArbeitsplaetze.getColumnModel().getColumn(i);
            switch (i) {
                //Nr
                case 0:
                    column.setPreferredWidth(30);
                    break;
                    //Beschreibung
                case 1:
                    column.setPreferredWidth(300);
                    break;
                    //Vorgänger
                case 2:
                    column.setPreferredWidth(80);
                    break;
                    //Nachfolger
                case 3:
                    column.setPreferredWidth(80);
                    break;
                    //Zeit
                case 4:
                    column.setPreferredWidth(40);
                    break;
                    //Eingangslager
                case 5:
                    column.setPreferredWidth(110);
                    break;
                    //Ausgangslager
                case 6:
                    column.setPreferredWidth(110);
                    break;
            }
        }
        jTableArbeitsplaetze.setDefaultRenderer( JComponent.class, new JComponentCellRenderer() );
        jTableArbeitsplaetze.setDefaultEditor( JComponent.class, new JComponentCellEditor() );
    }
    
    /** Erstellt die ArbeitsplatzLagerElementeTabelle. */
    public void setArbeitsplatzLagerElementeTabelle() {
        //DefaultTableModel mit Variablen Zeilen, 4 TableHeads und nicht editierbaren Zellen
        Object[][] tableInit = new Object[4][4];
        DefaultTableModel defTable = new DefaultTableModel(
        tableInit,
        new String [] {
            "Artikelname", "aktueller Bestand", "Max. Bestand", "Belegung"
        }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };
            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
            public Class getColumnClass(int c) {
                return getValueAt(0, c).getClass();
            }
        };
        jTableGesamtliste.setModel(defTable);
        jTableGesamtliste.setEnabled(false);
        jTableGesamtliste.getTableHeader().setReorderingAllowed(false);
    }
    
    /** Refreshed beide Tabellen */
    public void refreshArbeitsplatzLagerElementeTabelle() {
        
        //Refresh Tabelle Arbeitsplaetze
        try {
            arbeitsplaetze = dao.getArbeitsplaetze();
        } catch (WiSimDAOException e) {
            wiSimLogger.log("refreshArbeitsplatzLagerElementeTabelle()", e);
        }
        
        int i = 0;
        Iterator ap_it = arbeitsplaetze.iterator();
        while (ap_it.hasNext()) {
            Arbeitsplatz ap = (Arbeitsplatz) ap_it.next();
            
            ArbeitsplatzLager apLager = new ArbeitsplatzLager();
            try {
                apLager = dao.getArbeitsplatzLager(ap.getNr(), 26, "Eingang");
            } catch (WiSimDAOException e) {
                wiSimLogger.log("refreshArbeitsplatzLagerElementeTabelle()", e);
            }
            
            //Zelle wird nur refreshed wenn sich der Bestand geändert hat!
            if (!((String)tempEingangslagerBestand.get(i)).equals(String.valueOf(apLager.getBestand()))) {
                tempEingangslagerBestand.setElementAt(String.valueOf(apLager.getBestand()), i);
                jprg = new JProgressBar(0, 10);
                jprg.setValue(apLager.getBestand());
                jprg.setToolTipText("Bestand: " + apLager.getBestand());
                jTableArbeitsplaetze.setValueAt(jprg, i, 5);
            }
            
            try {
                apLager = dao.getArbeitsplatzLager(ap.getNr(), 26, "Ausgang");
            } catch (WiSimDAOException e) {
                wiSimLogger.log("refreshArbeitsplatzLagerElementeTabelle()", e);
            }
            
            //Zelle wird nur refreshed wenn sich der Bestand geändert hat!
            if (!((String)tempAusgangslagerBestand.get(i)).equals(String.valueOf(apLager.getBestand()))) {
                tempAusgangslagerBestand.setElementAt(String.valueOf(apLager.getBestand()), i);
                jprg = new JProgressBar(0, 10);
                jprg.setValue(apLager.getBestand());
                jprg.setToolTipText("Bestand: " + apLager.getBestand());
                jTableArbeitsplaetze.setValueAt(jprg, i, 6);
            }
            i++;
        }
        
        //Refresh Tabelle ArbeitsplatzLager
        if (jTableArbeitsplaetze.getSelectedRow() >= 0) {
            Arbeitsplatz ap = (Arbeitsplatz) arbeitsplaetze.get(jTableArbeitsplaetze.getSelectedRow());
            try {
                arbeitsplatzLager = dao.getArbeitsplatzLager(ap.getNr(), "Einzelteil");
            } catch (WiSimDAOException e) {
                wiSimLogger.log("refreshArbeitsplatzLagerElementeTabelle()", e);
            }
            apElemAnzahl = arbeitsplatzLager.size();
            i = 0;
            if (apElemAnzahl > 0) {
                Iterator arbeitsplatzLager_it = arbeitsplatzLager.iterator();
                while (arbeitsplatzLager_it.hasNext()) {
                    ArbeitsplatzLager apLager = (ArbeitsplatzLager) arbeitsplatzLager_it.next();
                    
                    //Zelle wird nur aktualisiert wenn sich der Bestand geändert hat.
                    if (jTableGesamtliste.getValueAt(i, 1) != null && !jTableGesamtliste.getValueAt(i, 1).equals("")) {
                        if (apLager.getBestand() != Integer.parseInt((String) jTableGesamtliste.getValueAt(i, 1))) {
                            Einzelteil et = new Einzelteil();
                            try {
                                et = dao.getEinzelteil(apLager.getEinzelteilNr());
                            } catch (WiSimDAOException e) {
                                wiSimLogger.log("refreshArbeitsplatzLagerElementeTabelle()", e);
                            }
                            
                            jTableGesamtliste.setValueAt(String.valueOf(apLager.getBestand()), i, 1);
                            
                            IconGenerater iconGen = new IconGenerater();
                            
                            double actBestand = apLager.getBestand();
                            double actMaxBestand = apLager.getMaxBestand();
                            
                            double rects = (double)(actBestand/actMaxBestand)*5;
                            int filledrectsCount = (int) Math.round(rects);
                            
                            if (apLager.getBestand() < (apLager.getMaxBestand()/4)) {
                                jTableGesamtliste.setValueAt(iconGen.generateIcon(2, filledrectsCount), i, 3);
                            } else if ((apLager.getBestand() < (apLager.getMaxBestand()/2))) {
                                jTableGesamtliste.setValueAt(iconGen.generateIcon(1, filledrectsCount), i, 3);
                            } else {
                                jTableGesamtliste.setValueAt(iconGen.generateIcon(0, filledrectsCount), i, 3);
                            }
                        }
                    }
                    i++;
                }
            } else {
                resetGesamtListe();
            }
        }
    }
    
    /** Löscht die GesamtListe unterhalb der Arbeitsplatztabelle. */
    public void resetGesamtListe() {
        int i = jTableGesamtliste.getRowCount()-1;
        while (i >= 0) {
            jTableGesamtliste.setValueAt("", 3-i, 0);
            jTableGesamtliste.setValueAt("", 3-i, 1);
            jTableGesamtliste.setValueAt("", 3-i, 2);
            jTableGesamtliste.setValueAt("", 3-i, 3);
            i--;
        }
    }
    
    /** Setzt die Zahl an Arbeiter an diesem Arbeitsplatz
     * @param apNr Arbeitsplatz Nr
     * @param anzahl Anzahl der Mitarbeiter
     */
    public void setArbeiterZahl(int apNr, Integer anzahl) {
        try {
            dao.setArbeiterZahl(apNr, anzahl.intValue());
        } catch (WiSimDAOWriteException e) {
            wiSimLogger.log("setArbeiterZahl()", e);
        }
        
        //Aktualisierung der arbeitsplaetze-Collection
        try {
            arbeitsplaetze = dao.getArbeitsplaetze();
        } catch (WiSimDAOException e) {
            wiSimLogger.log("setArbeiterZahl()", e);
        }
    }

    /** Setzt die Variable isBuilt
     * @param isBuilt
     */
    public void setIsBuilt(boolean isBuilt) {
        this.isBuilt = isBuilt;
    }
    
    /** Wurde das Pane schon einmal aufgebaut, so ist "isBuilt" = TRUE.
     *  Wichtig ist diese Variable für die Simulation: Wurde das Pane
     *  schon einmal aufgebaut, so müssen die Simulationsthread das Pane
     *  nicht noch einmal initialisieren!
     * @return boolean isBuilt
     */
    public boolean getIsBuilt() {
        return isBuilt;
    }
    
    /** Setzt die Variable isActive auf TRUE oder FALSE
     * @param isActive
     */
    public void setIsActive(boolean isActive) {
        this.isActive = isActive;
    }
    
    /** Befindet sich der Benutzer auf diesem Pane, so ist "isActive" = TRUE.
     *  Verlässt der Benutzer das Pane, so ist "isActive" = FALSE.
     *  Wichtig ist diese Variable für die Simulation: Es wird nur das Pane
     *  aktualisiert, auf dem sich der Benutzer gerade befindet!
     * @return boolean isActive
     */
    public boolean getIsActive() {
        return isActive;
    }
}